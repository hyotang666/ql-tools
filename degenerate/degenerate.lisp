(defpackage :ql-tools.degenerate
  (:use :cl)
  (:import-from :ql-tools.utility
                #:any-version-of
                #:system-source-files
                #:bottom-directory-namestring)
  (:export #:degenerate #:undo))

(in-package :ql-tools.degenerate)

(defvar *degenerated-directory*
  (uiop:merge-pathnames* "degenerated/"
                         (asdf:system-source-directory :ql-tools.degenerate)))

(macrolet ((mkdir (subdir)
             `(ensure-directories-exist
                (uiop:merge-pathnames* (concatenate 'string ,subdir "/")
                                       *degenerated-directory*))))
  (mkdir "systems")
  (mkdir "releases"))

(defun output
       (data pathname &key (if-does-not-exist :error) (if-exists :supersede))
  (with-open-file (*standard-output* pathname :direction :output
                   :if-does-not-exist if-does-not-exist
                   :if-exists if-exists)
    (write-line data)))

(defun setup ()
  (labels ((diverge ()
             (if (uiop:featurep :ros.init)
                 (may-set #'set-to-.roswell)
                 (may-set #'set-to-imple)))
           (may-set (setter)
             (unless (uiop:featurep :qlt-degenerate)
               (funcall setter)
               (pushnew :qlt-degenerate *features*)))
           (set-to-.roswell ()
             (output-load-form
               (uiop:merge-pathnames* ".roswell/init.lisp"
                                      (user-homedir-pathname))))
           (output-load-form (to)
             (output (the-load-form) to
                     :if-exists :append
                     :if-does-not-exist :create))
           (the-load-form ()
             (format nil
                     ";;;; This form is generated by QL-TOOLS.DEGENERATE~%~S"
                     `(progn
                       (ql:quickload :ql-tools.degenerate :silent t)
                       (pushnew :qlt-degenerate *features*))))
           (set-to-imple ()
             (if (not (uiop:featurep :quicklisp))
                 (error "Missing quicklisp.~&QL-TOOLS heavily depends on it.")
                 (let ((init-file (ql-impl-util::init-file-name)))
                   (if init-file
                       (output-load-form
                         (uiop:merge-pathnames* init-file
                                                (user-homedir-pathname)))
                       (error
                         "Don't know how to add to init file for your implementation."))))))
    (unless (uiop:featurep :qlt-degenerate)
      (diverge))))

(defun degenerate (system)
  (setup)
  (labels ((diverge (release versions)
             (if (probe-file release)
                 (main release (older-system release versions))
                 (main release versions)))
           (older-system (release older-systems)
             (nth
               (1+
                 (position
                   (bottom-directory-namestring (uiop:read-file-line release))
                   older-systems
                   :test #'string=
                   :key #'bottom-directory-namestring))
               older-systems))
           (main (release versions)
             (let ((older-system (second versions)))
               (if older-system
                   (%main older-system release)
                   (handle-restart release versions))))
           (%main (older-system release)
             (degenerate-release older-system release)
             (degenerate-systems older-system))
           (handle-restart (release versions)
             (if versions
                 (progn
                  (cerror "Force to do." "Only one version for ~S." system)
                  (%main (car versions) release))
                 (warn "System named ~S is not found." system)))
           (degenerate-release (older-system release)
             (%degenerate (namestring (system-homedir-pathname older-system))
                          release))
           (%degenerate (data to)
             (output data to :if-does-not-exist :create :if-exists :append))
           (degenerate-systems (older-system)
             (dolist (asd (system-source-files older-system))
               (%degenerate (relative-namestring asd)
                            (degenerated-pathname (pathname-name asd)
                                                  "systems")))))
    (diverge (degenerated-pathname system "releases") (any-version-of system))))

(defun system-homedir-pathname (thing) ; separated for easy testing.
  (labels ((upper-directories (pathname)
             (make-pathname :directory (rec (pathname-directory pathname))))
           (rec (components &optional acc)
             (if (endp components)
                 (error
                   "There is no \"software\" directory in pathname.~%so can not handle it. ~S"
                   thing)
                 (collect (car components) (cdr components) acc)))
           (collect (component rest acc)
             (if (string= "software" component)
                 (nreconc acc (list component (car rest)))
                 (rec rest (push component acc))))
           (asdf (system)
             (asdf:system-source-directory system))
           (quicklisp (system)
             (ql-dist:base-directory (ql-dist:release system))))
    (upper-directories
      (etypecase thing
        (asdf:system (asdf thing))
        ((or ql-dist:system ql-dist:release) (quicklisp thing))
        ((or pathname string) thing)))))

(defun degenerated-pathname (system subdir)
  (pathname
    (format nil "~A~@[~A~]/~(~A~).txt" (namestring *degenerated-directory*)
            subdir (string-downcase system))))

(defun degenerated-definition-searcher (system)
  (labels ((degenerated-definition-pathname (pathname)
             (uiop:merge-pathnames*
               (car (last (uiop:read-file-lines pathname)))
               (ql-dist:base-directory (ql-dist:dist :quicklisp)))))
    (let ((pathname (degenerated-pathname system "systems")))
      (when (probe-file pathname)
        (degenerated-definition-pathname pathname)))))

(push #'degenerated-definition-searcher
      asdf:*system-definition-search-functions*)

(defun relative-namestring (pathname) ; separeted for easy testing.
  (flet ((under-dists-components (components)
           (cons :relative (nthcdr
                             (position "software" components :test #'string=)
                             components))))
    (let ((directory (pathname-directory pathname)))
      (namestring
        (make-pathname :directory (under-dists-components directory)
                       :name (pathname-name pathname)
                       :type (pathname-type pathname))))))

(defun undo (system)
  (labels ((probe? (release)
             (when (probe-file release)
               (undo-atomic release (pathname (uiop:read-file-line release)))))
           (undo-atomic (release directory)
             (main release)
             (dolist (asd (system-source-files directory))
               (main (degenerated-pathname (pathname-name asd) "systems"))))
           (main (pathname)
             (let ((lines (uiop:read-file-lines pathname)))
               (cond
                ((cdr lines) ; have some.
                 (output (format nil "~{~A~%~}" (butlast lines)) pathname))
                ((car lines) ; hove one.
                 (delete-file pathname))))))
    (probe? (degenerated-pathname system "releases"))))